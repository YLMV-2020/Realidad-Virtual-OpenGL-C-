#ifndef DEBUG_DRAWER_HEADER
#define DEBUG_DRAWER_HEADER

namespace Cogravi
{
	struct Line {
		btVector3 from;
		btVector3 to;

		Line(btVector3 f, btVector3 t) {
			from = f;
			to = t;
		}
	};

	class DebugDrawer : public btIDebugDraw
	{
		int m_debugMode;
		GLuint vao, vbo, ebo, viewLoc, projLoc;
		glm::mat4 view;
		glm::mat4 proj;
		std::vector<Line> lines;

	public:

		Shader shader;

		DebugDrawer()
		{
			this->shader = Shader("assets/shaders/debug.vert", "assets/shaders/debug.frag");
			viewLoc = glGetUniformLocation(shader.ID, "view");
			projLoc = glGetUniformLocation(shader.ID, "projection");
		}
		~DebugDrawer() 
		{

		}

		void SetMatrices(glm::mat4 view, glm::mat4 proj)
		{
			this->view = view;
			this->proj = proj;
		}

		void drawLines()
		{
			int n = lines.size();
			GLuint* indices = new GLuint[n * 2 + 2];
			GLfloat* vertices = new GLfloat[3 * n * 2 + 2];

			for (int i = 0; i < n; i++)
			{
				vertices[6 * i] = lines.at(i).from.getX();
				vertices[6 * i + 1] = lines.at(i).from.getY();
				vertices[6 * i + 2] = lines.at(i).from.getZ();

				vertices[6 * i + 3] = lines.at(i).to.getX();
				vertices[6 * i + 4] = lines.at(i).to.getY();
				vertices[6 * i + 5] = lines.at(i).to.getZ();

				indices[2 * i] = i * 2;
				indices[2 * i + 1] = i * 2 + 1;
			}

			glGenVertexArrays(1, &vao);
			glGenBuffers(1, &vbo);
			glGenBuffers(1, &ebo);

			glBindVertexArray(vao);

			//UPLOADING VERTEX
			glBindBuffer(GL_ARRAY_BUFFER, vbo);
			glBufferData(GL_ARRAY_BUFFER,
				sizeof(GLfloat) * 3 * n * 2, vertices, GL_STATIC_DRAW);
			//UPLOADING INDEXES
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
			glBufferData(GL_ELEMENT_ARRAY_BUFFER,
				sizeof(GLuint) * 2 * n,
				indices,
				GL_STATIC_DRAW);
			glEnableVertexAttribArray(0);
			glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE,
				sizeof(GLfloat) * 3, (GLvoid*)0);
			glBindVertexArray(0);

			//use program
			glUseProgram(shader.ID);
			glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));
			glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(proj));

			//use geometry
			glBindVertexArray(vao);
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
			glDrawElements(GL_LINES, 2 * n, GL_UNSIGNED_INT, 0);
			glBindVertexArray(0);

			//delete buffers
			glDeleteVertexArrays(1, &vao);
			glDeleteBuffers(1, &vbo);
			glDeleteBuffers(1, &ebo);
			lines.clear();
		}

		virtual void setDebugMode(int debugMode) override { m_debugMode = debugMode; }
		virtual int getDebugMode() const override { return m_debugMode; }

		virtual void drawContactPoint(const btVector3& PointOnB, const btVector3& normalOnB, btScalar distance, int lifeTime, const btVector3& color)override{}
		virtual void draw3dText(const btVector3& location, const char* textString) override{}


		virtual void drawLine(const btVector3& from, const btVector3& to, const btVector3& color) override
		{
			lines.push_back(Line(from, to));
		}
		virtual void reportErrorWarning(const char* warningString) override
		{
			cout << warningString;
		}

		void ToggleDebugFlag(int flag)  {
			// checks if a flag is set and enables/
			// disables it
			if (m_debugMode & flag) {
				// flag is enabled, so disable it
				m_debugMode = m_debugMode & (~flag);
			}
			else {
				// flag is disabled, so enable it
				m_debugMode |= flag;
			}
		}

		

	};
}

#endif
